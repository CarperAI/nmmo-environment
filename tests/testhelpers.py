# pylint: disable=all

import numpy as np
from copy import deepcopy

import nmmo

from scripted import baselines


# this function can be replaced by assertDictEqual
# but might be still useful for debugging
def are_actions_equal(source_atn, target_atn, debug=True):

  # compare the numbers and player ids
  player_src = list(source_atn.keys())
  player_tgt = list(target_atn.keys())
  if player_src != player_tgt:
    if debug:
      print("players don't match")
    return False

  # for each player, compare the actions
  for ent_id in player_src:
    atn1 = source_atn[ent_id]
    atn2 = target_atn[ent_id]

    if list(atn1.keys()) != list(atn2.keys()):
      if debug:
        print("action keys don't match. player:", ent_id)
      return False

    for atn, args in atn1.items():
      if atn2[atn] != args:
        if debug:
          print("action args don't match. player:", ent_id, ", action:", atn)
        return False

  return True


# this function CANNOT be replaced by assertDictEqual
def are_observations_equal(source_obs, target_obs, debug=True):

  keys_src = list(source_obs.keys())
  keys_obs = list(target_obs.keys())
  if keys_src != keys_obs:
    if debug:
      print("entities don't match")
    return False

  for k in keys_src:
    ent_src = source_obs[k]
    ent_tgt = target_obs[k]
    if list(ent_src.keys()) != list(ent_tgt.keys()):
      if debug:
        print("entries don't match. key:", k)
      return False

    obj = ent_src.keys()
    for o in obj:
      obj_src = ent_src[o]
      obj_tgt = ent_tgt[o]
      if np.sum(obj_src != obj_tgt) > 0:
        if debug:
          print("objects don't match. key:", k, ', obj:', o)
        return False

  return True


def player_total(env):
  sum_gold = 0

  for ent in env.realm.players.values():
    sum_gold += ent.gold.val

  return sum_gold 


def count_actions(tick, actions):
  cnt_move = 0
  cnt_attack = 0
  cnt_sell = 0
  cnt_use = 0
  cnt_give = 0
  cnt_buy = 0

  for entID in list(actions.keys()):
    for atn, args in actions[entID].items():
      if atn == nmmo.action.Move:
        cnt_move += 1
      elif atn == nmmo.action.Attack:
        cnt_attack += 1
      elif atn == nmmo.action.Sell:
        cnt_sell += 1
      elif atn == nmmo.action.Use:
        cnt_use += 1
      elif atn == nmmo.action.Give:
        cnt_give += 1
      elif atn == nmmo.action.Buy:
        cnt_buy += 1
      else:
        print('not counted:', atn)

  print('Tick:', tick, ', alive agents:', len(actions.keys()), 
        ', atn cnts move:', cnt_move, ', attack:', cnt_attack, ', sell:', cnt_sell, 
        ', use:', cnt_use, ', give:', cnt_give, ', buy:', cnt_buy)

  return cnt_move, cnt_attack, cnt_sell, cnt_use, cnt_give, cnt_buy


class ScriptedAgentTestConfig(nmmo.config.Small, nmmo.config.AllGameSystems):

  __test__ = False

  LOG_ENV = True

  LOG_MILESTONES = True
  LOG_EVENTS = False # TODO: LOG_EVENTS needs to be fixed
  LOG_VERBOSE = False

  SPECIALIZE = True
  PLAYERS = [
          baselines.Fisher, baselines.Herbalist, baselines.Prospector, baselines.Carver, baselines.Alchemist,
          baselines.Melee, baselines.Range, baselines.Mage]


class ScriptedAgentTestEnv(nmmo.Env):
  '''
  EnvTest step() bypasses some differential treatments for scripted agents
  To do so, actions of scripted must be serialized using the serialize_actions function above
  '''
  __test__ = False

  def __init__(self, config: nmmo.config.Config, seed=None):
    super().__init__(config=config, seed=seed)
    # this is to cache the actions generated by scripted policies
    self.actions = {}

  def reset(self, map_id=None, seed=None, options=None):
    self.actions = {}
    return super().reset(map_id=map_id, seed=seed, options=options)

  def step(self, actions):
    assert self.obs is not None, 'step() called before reset'

    # all agent must be scripted agents
    for ent in self.realm.players.values():
      assert isinstance(ent.agent, baselines.Scripted) == True, 'All agent must be scripted.'

    # if actions are not provided, generate actions using the scripted policy
    if actions == {}:
      self.actions = {}
      for eid, ent in self.realm.players.items():
        # generate the serialized actions & cache these
        atns = ent.agent(self.obs[eid])
        self.actions[eid] = deepcopy(atns)
        
        # handle problematic values
        for atn, args in atns.items():
          for arg, val in args.items():
            if arg == nmmo.io.action.Price and type(val) != int:
              # <class 'nmmo.io.action.Price'>: <class 'nmmo.io.action.Discrete_1'>: convert Discrete_1 to 1
              self.actions[eid][atn][arg] = val.val
        
        #print(eid, self.actions[eid])

        # deserialize
        for atn, args in atns.items():
          for arg, val in args.items():
            #print(ent, val)
            atns[atn][arg] = arg.deserialize(self.realm, ent, val)
        actions[eid] = atns
    
    # if actions are provided, deserialize these
    else:

      # WARNING: this is a hack to set the random number generator to the same state
      # since scripted agents also use RNG. Without this, the RNG is in different state,
      # and the env.step() does not give the same results.
      for eid, ent in self.realm.players.items():
        ent.agent(self.obs[eid])

      # Now, process the received actions
      self.actions = deepcopy(actions)
      actions = {}
      for eid in self.actions.keys():
        assert eid in self.realm.players, f'Entity {eid} not in realm'
        ent = self.realm.players[eid]
        atns = deepcopy(self.actions[eid])

        #print(self.realm.tick, eid, atns)

        # deserialize
        for atn, args in atns.items():
          for arg, val in args.items():
            atns[atn][arg] = arg.deserialize(self.realm, ent, val)
            actions[eid] = atns

    dones = self.realm.step(actions)

    # Store the observations, since actions reference them
    self.obs = self._compute_observations()
    gym_obs = {a: o.to_gym() for a,o in self.obs.items()}

    rewards, infos = self._compute_rewards(self.obs.keys())

    return gym_obs, rewards, dones, infos
